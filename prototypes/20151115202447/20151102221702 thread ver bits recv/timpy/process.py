import threading
import functools
import Queue

class Event(object):

    def __init__(self, trigger_time, thread):
        self.trigger_time = trigger_time
        self.thread = thread

    def trigger(self):
        self.thread.resume()
        return self.thread

    def __repr__(self):
        return '<Event at {}>'.format(self.trigger_time)

class Thread(object):

    def __init__(self, f, name=None, *args, **kwargs):
        self.resumed = threading.Event()
        self.freezed = threading.Event()
        self.finished = False

        f = functools.partial(f, *args, **kwargs)
        f = self.make_report_at_finish(f)
        self.thread = threading.Thread(target=f)
        self.thread.daemon = True
        self.name = name or str(self.thread)

    def __repr__(self):
        return '<Thread {}>'.format(self.name)

    def make_report_at_finish(self, f):
        def f_():
            f()
            self.finished = True
            self.freezed.set()
        return f_

    def is_alive(self):
        return self.thread.is_alive()

    def start(self):
        self.thread.start()

    def resume(self):
        self.resumed.set()

    # called by worker thread
    def freeze(self):
        self.freezed.set()
        self.resumed.wait()
        self.resumed.clear()

    def wait_until_freezed(self):
        self.freezed.wait()
        self.freezed.clear()

class Environment(object):

    def __init__(self):
        self.threads = []
        self.now = 0
        self.events = []
        self.event_queue = Queue.Queue()

    def process(self, f, name=None, *args, **kwargs):
        thread = Thread(f, name, *args, **kwargs)
        self.threads.append(thread)
        return thread

    def run(self,
            terminate=lambda _: False,
            monitor=lambda _: None,
            debug=''):
        for thread in self.threads:
            thread.start()
        for thread in self.threads:
            thread.wait_until_freezed()
        while True:
            # extract events generated by other threads
            while not self.event_queue.empty():
                self.events.append(self.event_queue.get())
            # if no events, exit
            if not self.events:
                break
            # sort by trigger time
            self.events.sort(key=lambda t: t.trigger_time)
            # extract the most near future event
            self.current_event= self.events[0]
            if self.now != self.current_event.trigger_time:
                self.now = self.current_event.trigger_time
                if debug == 'time':
                    monitor(self)
            self.events.remove(self.current_event)
            # trigger the event
            if debug == 'event':
                monitor(self)
            if terminate():
                return
            thread = self.current_event.trigger()
            thread.wait_until_freezed()
            if thread.finished:
                self.threads.remove(thread)
        monitor(self)

    def schedule(self, event):
        self.event_queue.put(event)

    def timeout(self, unit):
        cur_thread = threading.current_thread()
        thread = next(t for t in self.threads if t.thread == cur_thread)
        self.schedule(Event(self.now + unit, thread))
        thread.freeze()

environment = Environment()
