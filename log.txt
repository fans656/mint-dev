2015-10-20 09:11:31
两个 link-layer switch (链路层交换机) 能彼此连接吗？
昨儿晚上看wiki说是switch根据MAC-端口映射来转发包，...
google了下，说是可以
之前以为不可以的，这么看来，switch有这样的功能：即不认识的MAC都从特定端口转发出去，之后就由这个端口连接的另一个switch来负责了

2015-10-20 10:26:36
[sim]
https://en.wikipedia.org/wiki/Collision_domain
) 模拟两台直连电脑间的collision
) 模拟三台通过hub(集线器)连接的..的collision

[learn]
https://en.wikipedia.org/wiki/Carrier_sense_multiple_access_with_collision_detection
CSMA/CD

2015-10-23 16:11:08
    sock.listen(backlog)
里头的backlog的含义有必要澄清，这个数是操作系统允许积压的尚未被accept的所有connection request(在这里就是一个SYN包)的最大个数
它说的不是服务器最多能维持几个tcp链接，而是说假如你accept得不够快的话，os最多帮你bookkeeping多少个链接请求

另外socket api里头分为 listen socket 和 data socket
其实在网络层面没这个区分，你 listen 在80就是80，这时还不存在connection，你只是跟os说了声“嘿，如果有人来找80，告我声啊”
(os是永远能收到发给任何端口的请求的，只是如果之前没有进程register在这个端口上，os就自己帮它回绝或者ignore了)
当请求到来的时候，只要有人监听，os就已经自作主张发回了ACK——不管你进程accept没有，这时其实connection就已经有了，在API层面由data socket代表，accept只是跟os取一下这个socket

2015-10-23 16:32:17
protocol定义了某一layer的两个entities之间的交互行为，两个entities可以逻辑上视为直接交互是因为下层layer提供的服务保证了它们正好看到自己层定义的协议
之前某处画的那个5层layer每层entities都交互实际上不准确，因为你看MAC层只能在双绞线两边儿交互，而IP层是确确实实穿过好多路由器交互的
所以更应该画成两边儿5层，中间经过几个3层
叫做53(年高考..模拟..囧)
4、5层直接交互，下面的是在每个hoop间交互的

2015-10-23 18:41:35
未来的学生会不会把Internet当作历史来学习；或者Internet只是更大的星际网络中一个古老的组成部分
连接地球和火星通信网的中间部分采用新的技术，使用新的协议

2015-10-24 14:31:39
关于带宽(bandwidth)和时延(latency)
设想一个传送带，这头儿有个搬运工往上放东西，他放的速度代表了带宽，即每秒能放上去多少字节的东西
传送带的速度以及距离决定了时延，即从这头儿放上去的东西需要多久能到那头儿

换个比喻，从一个城市到另一个城市的货运
我买了一条路，只能跑三轮儿，带宽相当小
你买了一条运河，大集装箱的轮船运，带宽极大

再来个，从地球到木星的链路，带宽不谈，时延大到简直了

最后一说：带宽就是圆柱体的截面

2015-10-26 19:17:24
computer networks (Andrew S. Tanenbaum) p86
这里说的很有意思，之前听说那些智能网络的概念还觉得对不对呀，是不是管得太多了？这里这个场景却确实很合适：
卫星通信是一种很便宜的broadcast——一个卫星的广播可以覆盖1/3个地球，把网络中cache的流量交给这种通信方式，点对点的交给线路通信
及至更细分的将流量类型与基础网络设施匹配的智能化调度，可以优化网络的使用

2015-10-28 19:01:45
https://www.grotto-networking.com/DiscreteEventPython.html
https://simpy.readthedocs.org/en/latest/
做到后面可能会用到simpy以及discrete event技术

2015-10-28 21:59:37
http://rpyc.readthedocs.org/en/latest/
想着用RPC来实现每个终端设备console中对终端的控制
python自带的xmlrpc弱爆了，object instance返回成dict
这个rpyc简直屌，完全是自己想象的样子，学名“transparent sysmmetric”

2015-10-29 12:34:21
感觉从GUI入手会蒙蔽逻辑，写得乱
打算下来先尝试用simpy做一个CLI的版本，然后再GUI化——GUI应该是独立于核心模拟的
也就是说不要GUI也能跑，而且可以有多个不同的GUI实现

2015-11-01 22:59:58
simpy必须用yield，没法二次封装，recv很难写
打算用线程重写，起手后发现不是那么简单——目前感觉至少相当于实现一个simpy的线程版

2015-11-02 09:43:03
有新想法了，琢磨了琢磨发觉用线程实现核心网(port, link)没有意义，做到最后还是各个线程间线性排队跑的，跟simpy一样
才意识到自己真正的需求只是api不要用yield，而这一点通过让用户写的entity逻辑代码跑在单独的线程中就可以
每个port自己维护一些threading.Event()
simpy里跑到相应的地方就给它们 e.set()
然后在用户代码里的wait()中，e.wait(); e.clear()
因为port到entity的关系是一对一的，所以不会有什么问题

2015-11-02 12:18:39
又思索了思索，意识到mint实际上需要支持两种模式
1) 实时网络
    开始运行后，所有线程模拟的那些硬件上，就已经有数据在不断地传输
    用户在GUI中点击某个电脑的send packet，另一边的数据流里，中间某处显出接收到的0101——前后都有线路噪声的0101
2) 逻辑网络
    所有网络中发生的行为都有精确的先后依赖
    比如可以保证pc1发送出1111的时候，链路上正好流过000的preamble

实时网络使用用户提供的entity线程、代码，所以不能用simpy的yield
逻辑网络可以使用simpy
但为了提供一致的接口(即用户代码中，用了mint的同步机制就是逻辑网络，不用就是实时网络)，所以只能使用线程

2015-11-04 11:52:35
之前写到hub就晕乎了，这些天来一直卡卡停停
昨儿跟肖师兄聊这个也聊了挺久
今儿终于搞定啦！精确时序，hub连3个host，啊哈哈哈
