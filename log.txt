2015-10-20 09:11:31
两个 link-layer switch (链路层交换机) 能彼此连接吗？
昨儿晚上看wiki说是switch根据MAC-端口映射来转发包，...
google了下，说是可以
之前以为不可以的，这么看来，switch有这样的功能：即不认识的MAC都从特定端口转发出去，之后就由这个端口连接的另一个switch来负责了

2015-10-20 10:26:36
[sim]
https://en.wikipedia.org/wiki/Collision_domain
) 模拟两台直连电脑间的collision
) 模拟三台通过hub(集线器)连接的..的collision

[learn]
https://en.wikipedia.org/wiki/Carrier_sense_multiple_access_with_collision_detection
CSMA/CD

2015-10-23 16:11:08
    sock.listen(backlog)
里头的backlog的含义有必要澄清，这个数是操作系统允许积压的尚未被accept的所有connection request(在这里就是一个SYN包)的最大个数
它说的不是服务器最多能维持几个tcp链接，而是说假如你accept得不够快的话，os最多帮你bookkeeping多少个链接请求

另外socket api里头分为 listen socket 和 data socket
其实在网络层面没这个区分，你 listen 在80就是80，这时还不存在connection，你只是跟os说了声“嘿，如果有人来找80，告我声啊”
(os是永远能收到发给任何端口的请求的，只是如果之前没有进程register在这个端口上，os就自己帮它回绝或者ignore了)
当请求到来的时候，只要有人监听，os就已经自作主张发回了ACK——不管你进程accept没有，这时其实connection就已经有了，在API层面由data socket代表，accept只是跟os取一下这个socket

2015-10-23 16:32:17
protocol定义了某一layer的两个entities之间的交互行为，两个entities可以逻辑上视为直接交互是因为下层layer提供的服务保证了它们正好看到自己层定义的协议
之前某处画的那个5层layer每层entities都交互实际上不准确，因为你看MAC层只能在双绞线两边儿交互，而IP层是确确实实穿过好多路由器交互的
所以更应该画成两边儿5层，中间经过几个3层
叫做53(年高考..模拟..囧)
4、5层直接交互，下面的是在每个hoop间交互的

2015-10-23 18:41:35
未来的学生会不会把Internet当作历史来学习；或者Internet只是更大的星际网络中一个古老的组成部分
连接地球和火星通信网的中间部分采用新的技术，使用新的协议

2015-10-24 14:31:39
关于带宽(bandwidth)和时延(latency)
设想一个传送带，这头儿有个搬运工往上放东西，他放的速度代表了带宽，即每秒能放上去多少字节的东西
传送带的速度以及距离决定了时延，即从这头儿放上去的东西需要多久能到那头儿

换个比喻，从一个城市到另一个城市的货运
我买了一条路，只能跑三轮儿，带宽相当小
你买了一条运河，大集装箱的轮船运，带宽极大

再来个，从地球到木星的链路，带宽不谈，时延大到简直了

最后一说：带宽就是圆柱体的截面

2015-10-26 19:17:24
computer networks (Andrew S. Tanenbaum) p86
这里说的很有意思，之前听说那些智能网络的概念还觉得对不对呀，是不是管得太多了？这里这个场景却确实很合适：
卫星通信是一种很便宜的broadcast——一个卫星的广播可以覆盖1/3个地球，把网络中cache的流量交给这种通信方式，点对点的交给线路通信
及至更细分的将流量类型与基础网络设施匹配的智能化调度，可以优化网络的使用

2015-10-28 19:01:45
https://www.grotto-networking.com/DiscreteEventPython.html
https://simpy.readthedocs.org/en/latest/
做到后面可能会用到simpy以及discrete event技术

2015-10-28 21:59:37
http://rpyc.readthedocs.org/en/latest/
想着用RPC来实现每个终端设备console中对终端的控制
python自带的xmlrpc弱爆了，object instance返回成dict
这个rpyc简直屌，完全是自己想象的样子，学名“transparent sysmmetric”

2015-10-29 12:34:21
感觉从GUI入手会蒙蔽逻辑，写得乱
打算下来先尝试用simpy做一个CLI的版本，然后再GUI化——GUI应该是独立于核心模拟的
也就是说不要GUI也能跑，而且可以有多个不同的GUI实现

2015-11-01 22:59:58
simpy必须用yield，没法二次封装，recv很难写
打算用线程重写，起手后发现不是那么简单——目前感觉至少相当于实现一个simpy的线程版

2015-11-02 09:43:03
有新想法了，琢磨了琢磨发觉用线程实现核心网(port, link)没有意义，做到最后还是各个线程间线性排队跑的，跟simpy一样
才意识到自己真正的需求只是api不要用yield，而这一点通过让用户写的entity逻辑代码跑在单独的线程中就可以
每个port自己维护一些threading.Event()
simpy里跑到相应的地方就给它们 e.set()
然后在用户代码里的wait()中，e.wait(); e.clear()
因为port到entity的关系是一对一的，所以不会有什么问题

2015-11-02 12:18:39
又思索了思索，意识到mint实际上需要支持两种模式
1) 实时网络
    开始运行后，所有线程模拟的那些硬件上，就已经有数据在不断地传输
    用户在GUI中点击某个电脑的send packet，另一边的数据流里，中间某处显出接收到的0101——前后都有线路噪声的0101
2) 逻辑网络
    所有网络中发生的行为都有精确的先后依赖
    比如可以保证pc1发送出1111的时候，链路上正好流过000的preamble

实时网络使用用户提供的entity线程、代码，所以不能用simpy的yield
逻辑网络可以使用simpy
但为了提供一致的接口(即用户代码中，用了mint的同步机制就是逻辑网络，不用就是实时网络)，所以只能使用线程

2015-11-04 11:52:35
之前写到hub就晕乎了，这些天来一直卡卡停停
昨儿跟肖师兄聊这个也聊了挺久
今儿终于搞定啦！精确时序，hub连3个host，啊哈哈哈

2015-11-04 13:13:56
描述一下目前的model:
In the first tik, what have the system done is allow all the entities to put the data (that they want to send) into the system's hardware world (i.e. ports).
Then comes the first tok.
The tok cosists of two phases: output and input.
In the output phase, ports pull the data given to them, set their output symbol accordingly (or '0' if there are no data given).
In the input phase, ports detect their peer's output symbol, convert into bits and push to their entity.

So a `recv` will block in the first tik, and only after the first tok, in the second tik will it be able to fetch one bit.

A tok will transfer one bit along a peered ports, a tik after it then will process this bit.

In the scene of links or hubs, their bit process is take one port's bit and give it to another port, we call this a "port pimp". The take requires one previous tok, and the give occured in one tik. These comprise into a full tik-tok step. So a bit travels along the network path will be delayed on every "port pimper" at least 1 tik-tok. If the pimper it self `wait` in the process, then the bit will be delayed more tik-tok. For example, in a system where a link with latency of 3 linking two hosts, the data transfer latency between the hosts will be 4.

2015-11-04 22:40:18
https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing
https://pypi.python.org/pypi/cobs
COBS - Consistent Overhead Byte Stuffing
    一种 framing protocol
    PPP 也会做 framing

https://en.wikipedia.org/wiki/High-Level_Data_Link_Control
https://www.quora.com/What-is-the-purpose-of-bit-stuffing-and-byte-stuffing-in-computer-communication
HDLC 用的是 bit stuffing
好像在asynchronous framming中也会用byte stuffing

https://networkengineering.stackexchange.com/questions/13233/bit-and-byte-stuffing-in-hdlc-frames/13281#13281?newreg=c9fe3315235f42599c1823467da64d4d
看样子说两种stuffing的使用场景不同：
    bit stuffing - synchronous serial link
    byte stuffing - asynchronous serial link (e.g. RS-232)

2015-11-04 23:55:54
http://www.sangoma.com/tutorials/sync_n_async/
这里讲解了 sychronous/asynchronous communication

2015-11-05 08:24:06
https://networkengineering.stackexchange.com/questions/5263/why-is-the-ethernet-frame-size-fixed
这里讲了为啥Ethernet的frame有最小/最大长度限制
主要是由于collision detection的需要，CSMA/CD啥的
这个framing之后再做

https://networkengineering.stackexchange.com/questions/10423/how-long-is-a-frame-really-supposed-to-be-and-when-is-a-frame-a-babble
and mark
